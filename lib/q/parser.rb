# Autogenerated from a Treetop grammar. Edits may be lost.


require 'q/scope'
require 'q/syntax'

module Q
  include Treetop::Runtime

  def root
    @root ||= :statements
  end

  module Statements0
    def statement
      elements[1]
    end

  end

  module Statements1
    def statements
      elements[0]
    end

  end

  module Statements2
    def eval scope
      statements.elements.each do |statement|
        statement.statement.eval scope
      end

      scope['_']
    end
  end

  def _nt_statements
    start_index = index
    if node_cache[:statements].has_key?(index)
      cached = node_cache[:statements][index]
      if cached
        node_cache[:statements][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      s3, i3 = [], index
      loop do
        r4 = _nt_ws
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s2 << r3
      if r3
        i5 = index
        r6 = _nt_comment
        if r6
          r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
          r5 = r6
        else
          r7 = _nt_statement
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r5 = r7
          else
            @index = i5
            r5 = nil
          end
        end
        s2 << r5
        if r5
          s8, i8 = [], index
          loop do
            r9 = _nt_ws
            if r9
              s8 << r9
            else
              break
            end
          end
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          s2 << r8
        end
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Statements0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      s10, i10 = [], index
      loop do
        r11 = _nt_ws
        if r11
          s10 << r11
        else
          break
        end
      end
      r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
      s0 << r10
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Statements1)
      r0.extend(Statements2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:statements][start_index] = r0

    r0
  end

  module Statement0
    def expression
      elements[0]
    end

  end

  module Statement1
    def eval scope
      scope['_'] = expression.eval scope
    end
  end

  def _nt_statement
    start_index = index
    if node_cache[:statement].has_key?(index)
      cached = node_cache[:statement][index]
      if cached
        node_cache[:statement][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_expression
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?(';', false, index))
          r4 = true
          @index += match_len
        else
          terminal_parse_failure(';')
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Statement0)
      r0.extend(Statement1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:statement][start_index] = r0

    r0
  end

  def _nt_expression
    start_index = index
    if node_cache[:expression].has_key?(index)
      cached = node_cache[:expression][index]
      if cached
        node_cache[:expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_call
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_assignment
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_conditional
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_binomial
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:expression][start_index] = r0

    r0
  end

  module Function0
    def identifier
      elements[1]
    end

  end

  module Function1
    def arguments
      elements[1]
    end

    def statements
      elements[4]
    end

  end

  def _nt_function
    start_index = index
    if node_cache[:function].has_key?(index)
      cached = node_cache[:function][index]
      if cached
        node_cache[:function][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('(', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        s4, i4 = [], index
        loop do
          r5 = _nt_ws
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s3 << r4
        if r4
          r6 = _nt_identifier
          s3 << r6
          if r6
            s7, i7 = [], index
            loop do
              r8 = _nt_ws
              if r8
                s7 << r8
              else
                break
              end
            end
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            s3 << r7
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Function0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?(')', false, index))
          r9 = true
          @index += match_len
        else
          terminal_parse_failure(')')
          r9 = nil
        end
        s0 << r9
        if r9
          if (match_len = has_terminal?('{', false, index))
            r10 = true
            @index += match_len
          else
            terminal_parse_failure('{')
            r10 = nil
          end
          s0 << r10
          if r10
            r11 = _nt_statements
            s0 << r11
            if r11
              if (match_len = has_terminal?('}', false, index))
                r12 = true
                @index += match_len
              else
                terminal_parse_failure('}')
                r12 = nil
              end
              s0 << r12
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Q::Syntax::Function,input, i0...index, s0)
      r0.extend(Function1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:function][start_index] = r0

    r0
  end

  module Assignment0
    def destination
      elements[0]
    end

    def expression
      elements[4]
    end
  end

  module Assignment1
    def eval scope
      scope['_'] = scope[destination.text_value] = expression.eval scope
    end
  end

  def _nt_assignment
    start_index = index
    if node_cache[:assignment].has_key?(index)
      cached = node_cache[:assignment][index]
      if cached
        node_cache[:assignment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_self
    if r2
      r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
      r1 = r2
    else
      r3 = _nt_identifier
      if r3
        r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      s4, i4 = [], index
      loop do
        r5 = _nt_ws
        if r5
          s4 << r5
        else
          break
        end
      end
      r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
      s0 << r4
      if r4
        if (match_len = has_terminal?('<:', false, index))
          r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('<:')
          r6 = nil
        end
        s0 << r6
        if r6
          s7, i7 = [], index
          loop do
            r8 = _nt_ws
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s0 << r7
          if r7
            r9 = _nt_expression
            s0 << r9
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Assignment0)
      r0.extend(Assignment1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assignment][start_index] = r0

    r0
  end

  module Call0
    def argument
      elements[1]
    end

  end

  module Call1
    def name
      elements[0]
    end

    def arguments
      elements[3]
    end

  end

  module Call2
    def eval scope
      scope['_'] = name.eval(scope).call(callscope(scope))
    end

    def callscope scope
      cscope = Q::Scope.new scope

      cscope.args = arguments.elements.map.each do |argument|
        argument.argument.eval(scope)
      end

      cscope
    end
  end

  def _nt_call
    start_index = index
    if node_cache[:call].has_key?(index)
      cached = node_cache[:call][index]
      if cached
        node_cache[:call][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_function
    if r2
      r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
      r1 = r2
    else
      r3 = _nt_self
      if r3
        r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
        r1 = r3
      else
        r4 = _nt_identifier
        if r4
          r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
          r1 = r4
        else
          @index = i1
          r1 = nil
        end
      end
    end
    s0 << r1
    if r1
      s5, i5 = [], index
      loop do
        r6 = _nt_ws
        if r6
          s5 << r6
        else
          break
        end
      end
      r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
      s0 << r5
      if r5
        if (match_len = has_terminal?('(', false, index))
          r7 = true
          @index += match_len
        else
          terminal_parse_failure('(')
          r7 = nil
        end
        s0 << r7
        if r7
          s8, i8 = [], index
          loop do
            i9, s9 = index, []
            s10, i10 = [], index
            loop do
              r11 = _nt_ws
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s9 << r10
            if r10
              r12 = _nt_expression
              s9 << r12
              if r12
                s13, i13 = [], index
                loop do
                  r14 = _nt_ws
                  if r14
                    s13 << r14
                  else
                    break
                  end
                end
                r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                s9 << r13
              end
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(Call0)
            else
              @index = i9
              r9 = nil
            end
            if r9
              s8 << r9
            else
              break
            end
          end
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          s0 << r8
          if r8
            if (match_len = has_terminal?(')', false, index))
              r15 = true
              @index += match_len
            else
              terminal_parse_failure(')')
              r15 = nil
            end
            s0 << r15
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Call1)
      r0.extend(Call2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:call][start_index] = r0

    r0
  end

  module Binomial0
    def operator
      elements[1]
    end

    def feet
      elements[3]
    end
  end

  module Binomial1
    def head
      elements[0]
    end

    def tail
      elements[2]
    end
  end

  module Binomial2
    def eval scope
      if has_feet?
        return operator.apply(scope, head, feet)
      end

      scope['_'] = head.eval(scope)
    end

    def has_feet?
      not tail.nil? and not tail.elements.first.nil? and not tail.elements.first.feet.nil?
    end

    def feet
      return nil if not has_feet?

      tail.elements.first.feet
    end

    def operator
      return nil if not has_feet?

      tail.elements.first.operator
    end
  end

  def _nt_binomial
    start_index = index
    if node_cache[:binomial].has_key?(index)
      cached = node_cache[:binomial][index]
      if cached
        node_cache[:binomial][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_monomial
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        s4, i4 = [], index
        loop do
          i5, s5 = index, []
          s6, i6 = [], index
          loop do
            r7 = _nt_ws
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s5 << r6
          if r6
            r8 = _nt_binomial_operator
            s5 << r8
            if r8
              s9, i9 = [], index
              loop do
                r10 = _nt_ws
                if r10
                  s9 << r10
                else
                  break
                end
              end
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              s5 << r9
              if r9
                r11 = _nt_monomial
                s5 << r11
              end
            end
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Binomial0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Binomial1)
      r0.extend(Binomial2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:binomial][start_index] = r0

    r0
  end

  module Monomial0
    def operator
      elements[1]
    end

    def feet
      elements[3]
    end
  end

  module Monomial1
    def head
      elements[0]
    end

    def tail
      elements[2]
    end
  end

  module Monomial2
    def eval scope
      if has_feet?
        feet = tail.elements.first.feet
        return operator.apply(scope, head, feet)
      end

      scope['_'] = head.eval(scope)
    end

    def has_feet?
      not tail.nil? and not tail.elements.first.nil? and not tail.elements.first.feet.nil?
    end

    def operator
      return nil if not has_feet?

      tail.elements.first.operator
    end
  end

  def _nt_monomial
    start_index = index
    if node_cache[:monomial].has_key?(index)
      cached = node_cache[:monomial][index]
      if cached
        node_cache[:monomial][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_primary
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        s4, i4 = [], index
        loop do
          i5, s5 = index, []
          s6, i6 = [], index
          loop do
            r7 = _nt_ws
            if r7
              s6 << r7
            else
              break
            end
          end
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          s5 << r6
          if r6
            r8 = _nt_monomial_operator
            s5 << r8
            if r8
              s9, i9 = [], index
              loop do
                r10 = _nt_ws
                if r10
                  s9 << r10
                else
                  break
                end
              end
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              s5 << r9
              if r9
                r11 = _nt_monomial
                s5 << r11
              end
            end
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Monomial0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Monomial1)
      r0.extend(Monomial2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:monomial][start_index] = r0

    r0
  end

  module Conditional0
    def consequence
      elements[4]
    end

  end

  module Conditional1
    def condition
      elements[3]
    end

    def consequence
      elements[9]
    end

    def otherwise
      elements[11]
    end
  end

  def _nt_conditional
    start_index = index
    if node_cache[:conditional].has_key?(index)
      cached = node_cache[:conditional][index]
      if cached
        node_cache[:conditional][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('if', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('if')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?('[', false, index))
          r4 = true
          @index += match_len
        else
          terminal_parse_failure('[')
          r4 = nil
        end
        s0 << r4
        if r4
          i5 = index
          r6 = _nt_conditional_expression
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r5 = r6
          else
            r7 = _nt_statements
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r5 = r7
            else
              @index = i5
              r5 = nil
            end
          end
          s0 << r5
          if r5
            if (match_len = has_terminal?(']', false, index))
              r8 = true
              @index += match_len
            else
              terminal_parse_failure(']')
              r8 = nil
            end
            s0 << r8
            if r8
              s9, i9 = [], index
              loop do
                r10 = _nt_ws
                if r10
                  s9 << r10
                else
                  break
                end
              end
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              s0 << r9
              if r9
                if (match_len = has_terminal?('then', false, index))
                  r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('then')
                  r11 = nil
                end
                s0 << r11
                if r11
                  s12, i12 = [], index
                  loop do
                    r13 = _nt_ws
                    if r13
                      s12 << r13
                    else
                      break
                    end
                  end
                  r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                  s0 << r12
                  if r12
                    if (match_len = has_terminal?('[', false, index))
                      r14 = true
                      @index += match_len
                    else
                      terminal_parse_failure('[')
                      r14 = nil
                    end
                    s0 << r14
                    if r14
                      i15 = index
                      r16 = _nt_conditional_expression
                      if r16
                        r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                        r15 = r16
                      else
                        r17 = _nt_statements
                        if r17
                          r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                          r15 = r17
                        else
                          @index = i15
                          r15 = nil
                        end
                      end
                      s0 << r15
                      if r15
                        if (match_len = has_terminal?(']', false, index))
                          r18 = true
                          @index += match_len
                        else
                          terminal_parse_failure(']')
                          r18 = nil
                        end
                        s0 << r18
                        if r18
                          i20, s20 = index, []
                          s21, i21 = [], index
                          loop do
                            r22 = _nt_ws
                            if r22
                              s21 << r22
                            else
                              break
                            end
                          end
                          r21 = instantiate_node(SyntaxNode,input, i21...index, s21)
                          s20 << r21
                          if r21
                            if (match_len = has_terminal?('else', false, index))
                              r23 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('else')
                              r23 = nil
                            end
                            s20 << r23
                            if r23
                              s24, i24 = [], index
                              loop do
                                r25 = _nt_ws
                                if r25
                                  s24 << r25
                                else
                                  break
                                end
                              end
                              r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                              s20 << r24
                              if r24
                                if (match_len = has_terminal?('[', false, index))
                                  r26 = true
                                  @index += match_len
                                else
                                  terminal_parse_failure('[')
                                  r26 = nil
                                end
                                s20 << r26
                                if r26
                                  i27 = index
                                  r28 = _nt_conditional_expression
                                  if r28
                                    r28 = SyntaxNode.new(input, (index-1)...index) if r28 == true
                                    r27 = r28
                                  else
                                    r29 = _nt_statements
                                    if r29
                                      r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                                      r27 = r29
                                    else
                                      @index = i27
                                      r27 = nil
                                    end
                                  end
                                  s20 << r27
                                  if r27
                                    if (match_len = has_terminal?(']', false, index))
                                      r30 = true
                                      @index += match_len
                                    else
                                      terminal_parse_failure(']')
                                      r30 = nil
                                    end
                                    s20 << r30
                                  end
                                end
                              end
                            end
                          end
                          if s20.last
                            r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                            r20.extend(Conditional0)
                          else
                            @index = i20
                            r20 = nil
                          end
                          if r20
                            r19 = r20
                          else
                            r19 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r19
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Q::Syntax::Conditional,input, i0...index, s0)
      r0.extend(Conditional1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:conditional][start_index] = r0

    r0
  end

  module ConditionalExpression0
    def expression
      elements[1]
    end

  end

  module ConditionalExpression1
    def eval scope
      expression.eval scope
    end
  end

  def _nt_conditional_expression
    start_index = index
    if node_cache[:conditional_expression].has_key?(index)
      cached = node_cache[:conditional_expression][index]
      if cached
        node_cache[:conditional_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_ws
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r3 = _nt_expression
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_ws
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
        if r4
          i6 = index
          if (match_len = has_terminal?(']', false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure(']')
            r7 = nil
          end
          if r7
            @index = i6
            r6 = instantiate_node(SyntaxNode,input, index...index)
          else
            r6 = nil
          end
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ConditionalExpression0)
      r0.extend(ConditionalExpression1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:conditional_expression][start_index] = r0

    r0
  end

  module Primary0
    def expression
      elements[2]
    end

  end

  module Primary1
    def eval scope
      scope['_'] = expression.eval(scope)
    end
  end

  def _nt_primary
    start_index = index
    if node_cache[:primary].has_key?(index)
      cached = node_cache[:primary][index]
      if cached
        node_cache[:primary][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_call
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_function
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_self
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_unary
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            r5 = _nt_value
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              r6 = _nt_identifier
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                i7, s7 = index, []
                if (match_len = has_terminal?('(', false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('(')
                  r8 = nil
                end
                s7 << r8
                if r8
                  s9, i9 = [], index
                  loop do
                    r10 = _nt_ws
                    if r10
                      s9 << r10
                    else
                      break
                    end
                  end
                  r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                  s7 << r9
                  if r9
                    r11 = _nt_expression
                    s7 << r11
                    if r11
                      s12, i12 = [], index
                      loop do
                        r13 = _nt_ws
                        if r13
                          s12 << r13
                        else
                          break
                        end
                      end
                      r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                      s7 << r12
                      if r12
                        if (match_len = has_terminal?(')', false, index))
                          r14 = true
                          @index += match_len
                        else
                          terminal_parse_failure(')')
                          r14 = nil
                        end
                        s7 << r14
                      end
                    end
                  end
                end
                if s7.last
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                  r7.extend(Primary0)
                  r7.extend(Primary1)
                else
                  @index = i7
                  r7 = nil
                end
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r0 = r7
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:primary][start_index] = r0

    r0
  end

  def _nt_binomial_operator
    start_index = index
    if node_cache[:binomial_operator].has_key?(index)
      cached = node_cache[:binomial_operator][index]
      if cached
        node_cache[:binomial_operator][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_minus
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_plus
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_comparison_operators
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:binomial_operator][start_index] = r0

    r0
  end

  def _nt_monomial_operator
    start_index = index
    if node_cache[:monomial_operator].has_key?(index)
      cached = node_cache[:monomial_operator][index]
      if cached
        node_cache[:monomial_operator][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_slash
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_star
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:monomial_operator][start_index] = r0

    r0
  end

  def _nt_unary
    start_index = index
    if node_cache[:unary].has_key?(index)
      cached = node_cache[:unary][index]
      if cached
        node_cache[:unary][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_negative
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_negation
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:unary][start_index] = r0

    r0
  end

  module Negation0
    def primary
      elements[2]
    end
  end

  module Negation1
    def eval scope
      not primary.eval(scope)
    end
  end

  def _nt_negation
    start_index = index
    if node_cache[:negation].has_key?(index)
      cached = node_cache[:negation][index]
      if cached
        node_cache[:negation][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('!', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('!')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_primary
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Negation0)
      r0.extend(Negation1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:negation][start_index] = r0

    r0
  end

  module Negative0
    def primary
      elements[2]
    end
  end

  module Negative1
    def eval scope
      - primary.eval(scope)
    end
  end

  def _nt_negative
    start_index = index
    if node_cache[:negative].has_key?(index)
      cached = node_cache[:negative][index]
      if cached
        node_cache[:negative][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('-', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('-')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_ws
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_primary
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Negative0)
      r0.extend(Negative1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:negative][start_index] = r0

    r0
  end

  def _nt_comparison_operators
    start_index = index
    if node_cache[:comparison_operators].has_key?(index)
      cached = node_cache[:comparison_operators][index]
      if cached
        node_cache[:comparison_operators][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_lt
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_lte
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_gt
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_gte
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            r5 = _nt_neq
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              r6 = _nt_eq
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:comparison_operators][start_index] = r0

    r0
  end

  module Lt0
    def apply scope, a, b
      a.eval(scope) < b.eval(scope)
    end
  end

  def _nt_lt
    start_index = index
    if node_cache[:lt].has_key?(index)
      cached = node_cache[:lt][index]
      if cached
        node_cache[:lt][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('<', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Lt0)
      @index += match_len
    else
      terminal_parse_failure('<')
      r0 = nil
    end

    node_cache[:lt][start_index] = r0

    r0
  end

  module Gt0
    def apply scope, a, b
      a.eval(scope) > b.eval(scope)
    end
  end

  def _nt_gt
    start_index = index
    if node_cache[:gt].has_key?(index)
      cached = node_cache[:gt][index]
      if cached
        node_cache[:gt][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('>', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Gt0)
      @index += match_len
    else
      terminal_parse_failure('>')
      r0 = nil
    end

    node_cache[:gt][start_index] = r0

    r0
  end

  module Lte0
    def apply scope, a, b
      a.eval(scope) <= b.eval(scope)
    end
  end

  def _nt_lte
    start_index = index
    if node_cache[:lte].has_key?(index)
      cached = node_cache[:lte][index]
      if cached
        node_cache[:lte][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('<=', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Lte0)
      @index += match_len
    else
      terminal_parse_failure('<=')
      r0 = nil
    end

    node_cache[:lte][start_index] = r0

    r0
  end

  module Gte0
    def apply scope, a, b
      a.eval(scope) >= b.eval(scope)
    end
  end

  def _nt_gte
    start_index = index
    if node_cache[:gte].has_key?(index)
      cached = node_cache[:gte][index]
      if cached
        node_cache[:gte][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('>=', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Gte0)
      @index += match_len
    else
      terminal_parse_failure('>=')
      r0 = nil
    end

    node_cache[:gte][start_index] = r0

    r0
  end

  module Eq0
    def apply scope, a, b
      a.eval(scope) == b.eval(scope)
    end
  end

  def _nt_eq
    start_index = index
    if node_cache[:eq].has_key?(index)
      cached = node_cache[:eq][index]
      if cached
        node_cache[:eq][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('=', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Eq0)
      @index += match_len
    else
      terminal_parse_failure('=')
      r0 = nil
    end

    node_cache[:eq][start_index] = r0

    r0
  end

  module Neq0
    def apply scope, a, b
      a.eval(scope) != b.eval(scope)
    end
  end

  def _nt_neq
    start_index = index
    if node_cache[:neq].has_key?(index)
      cached = node_cache[:neq][index]
      if cached
        node_cache[:neq][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('!=', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Neq0)
      @index += match_len
    else
      terminal_parse_failure('!=')
      r0 = nil
    end

    node_cache[:neq][start_index] = r0

    r0
  end

  module Plus0
    def apply scope, a, b
      scope['_'] = a.eval(scope) + b.eval(scope)
    end
  end

  def _nt_plus
    start_index = index
    if node_cache[:plus].has_key?(index)
      cached = node_cache[:plus][index]
      if cached
        node_cache[:plus][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('+', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Plus0)
      @index += match_len
    else
      terminal_parse_failure('+')
      r0 = nil
    end

    node_cache[:plus][start_index] = r0

    r0
  end

  module Minus0
    def apply scope, a, b
      scope['_'] = a.eval(scope) - b.eval(scope)
    end
  end

  def _nt_minus
    start_index = index
    if node_cache[:minus].has_key?(index)
      cached = node_cache[:minus][index]
      if cached
        node_cache[:minus][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('-', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Minus0)
      @index += match_len
    else
      terminal_parse_failure('-')
      r0 = nil
    end

    node_cache[:minus][start_index] = r0

    r0
  end

  module Star0
    def apply scope, a, b
      scope['_'] = a.eval(scope) * b.eval(scope)
    end
  end

  def _nt_star
    start_index = index
    if node_cache[:star].has_key?(index)
      cached = node_cache[:star][index]
      if cached
        node_cache[:star][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('*', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Star0)
      @index += match_len
    else
      terminal_parse_failure('*')
      r0 = nil
    end

    node_cache[:star][start_index] = r0

    r0
  end

  module Slash0
    def apply scope, a, b
      scope['_'] = a.eval(scope) / b.eval(scope)
    end
  end

  def _nt_slash
    start_index = index
    if node_cache[:slash].has_key?(index)
      cached = node_cache[:slash][index]
      if cached
        node_cache[:slash][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('/', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Slash0)
      @index += match_len
    else
      terminal_parse_failure('/')
      r0 = nil
    end

    node_cache[:slash][start_index] = r0

    r0
  end

  def _nt_value
    start_index = index
    if node_cache[:value].has_key?(index)
      cached = node_cache[:value][index]
      if cached
        node_cache[:value][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_number
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_string
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_truth
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_lie
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            r5 = _nt_nil
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:value][start_index] = r0

    r0
  end

  module Truth0
    def eval scope
      return true
    end
  end

  def _nt_truth
    start_index = index
    if node_cache[:truth].has_key?(index)
      cached = node_cache[:truth][index]
      if cached
        node_cache[:truth][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('true', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Truth0)
      @index += match_len
    else
      terminal_parse_failure('true')
      r0 = nil
    end

    node_cache[:truth][start_index] = r0

    r0
  end

  module Lie0
    def eval scope
      return false
    end
  end

  def _nt_lie
    start_index = index
    if node_cache[:lie].has_key?(index)
      cached = node_cache[:lie][index]
      if cached
        node_cache[:lie][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('false', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Lie0)
      @index += match_len
    else
      terminal_parse_failure('false')
      r0 = nil
    end

    node_cache[:lie][start_index] = r0

    r0
  end

  module Nil0
    def eval scope
      return nil
    end
  end

  def _nt_nil
    start_index = index
    if node_cache[:nil].has_key?(index)
      cached = node_cache[:nil][index]
      if cached
        node_cache[:nil][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('nil', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Nil0)
      @index += match_len
    else
      terminal_parse_failure('nil')
      r0 = nil
    end

    node_cache[:nil][start_index] = r0

    r0
  end

  def _nt_string
    start_index = index
    if node_cache[:string].has_key?(index)
      cached = node_cache[:string][index]
      if cached
        node_cache[:string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_single_quote_string
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_double_quote_string
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:string][start_index] = r0

    r0
  end

  module SingleQuoteString0
  end

  module SingleQuoteString1
    def content
      elements[1]
    end

  end

  module SingleQuoteString2
    def eval scope
      content.text_value.gsub '\\\'', "'"
    end
  end

  def _nt_single_quote_string
    start_index = index
    if node_cache[:single_quote_string].has_key?(index)
      cached = node_cache[:single_quote_string][index]
      if cached
        node_cache[:single_quote_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?("'", false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure("'")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        if (match_len = has_terminal?("\\'", false, index))
          r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure("\\'")
          r4 = nil
        end
        if r4
          r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
          r3 = r4
        else
          i5, s5 = index, []
          i6 = index
          if (match_len = has_terminal?("'", false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure("'")
            r7 = nil
          end
          if r7
            r6 = nil
          else
            @index = i6
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s5 << r6
          if r6
            if index < input_length
              r8 = true
              @index += 1
            else
              terminal_parse_failure("any character")
              r8 = nil
            end
            s5 << r8
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(SingleQuoteString0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r3 = r5
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?("'", false, index))
          r9 = true
          @index += match_len
        else
          terminal_parse_failure("'")
          r9 = nil
        end
        s0 << r9
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SingleQuoteString1)
      r0.extend(SingleQuoteString2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:single_quote_string][start_index] = r0

    r0
  end

  module DoubleQuoteString0
  end

  module DoubleQuoteString1
    def content
      elements[1]
    end

  end

  module DoubleQuoteString2
    def eval scope
      content.text_value.gsub '\"', '"'
    end
  end

  def _nt_double_quote_string
    start_index = index
    if node_cache[:double_quote_string].has_key?(index)
      cached = node_cache[:double_quote_string][index]
      if cached
        node_cache[:double_quote_string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('"', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        if (match_len = has_terminal?('\"', false, index))
          r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\"')
          r4 = nil
        end
        if r4
          r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
          r3 = r4
        else
          i5, s5 = index, []
          i6 = index
          if (match_len = has_terminal?('"', false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure('"')
            r7 = nil
          end
          if r7
            r6 = nil
          else
            @index = i6
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s5 << r6
          if r6
            if index < input_length
              r8 = true
              @index += 1
            else
              terminal_parse_failure("any character")
              r8 = nil
            end
            s5 << r8
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(DoubleQuoteString0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r3 = r5
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if (match_len = has_terminal?('"', false, index))
          r9 = true
          @index += match_len
        else
          terminal_parse_failure('"')
          r9 = nil
        end
        s0 << r9
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(DoubleQuoteString1)
      r0.extend(DoubleQuoteString2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:double_quote_string][start_index] = r0

    r0
  end

  module Number0
    def point
      elements[1]
    end

  end

  module Number1
    def eval scope
      if point.empty?
        return scope['_'] = text_value.to_i
      end

      scope['_'] = text_value.to_f
    end
  end

  def _nt_number
    start_index = index
    if node_cache[:number].has_key?(index)
      cached = node_cache[:number][index]
      if cached
        node_cache[:number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
        r2 = true
        @index += 1
      else
        terminal_parse_failure('[0-9]')
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('.', false, index))
        r4 = true
        @index += match_len
      else
        terminal_parse_failure('.')
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        s5, i5 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r6 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r6 = nil
          end
          if r6
            s5 << r6
          else
            break
          end
        end
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Number0)
      r0.extend(Number1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:number][start_index] = r0

    r0
  end

  module Identifier0
  end

  module Identifier1
    def eval scope
      scope['_'] = scope[text_value]
    end
  end

  def _nt_identifier
    start_index = index
    if node_cache[:identifier].has_key?(index)
      cached = node_cache[:identifier][index]
      if cached
        node_cache[:identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?(@regexps[gr = '\A[a-zA-Z_]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[a-zA-Z_]')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?(@regexps[gr = '\A[a-zA-Z0-9_]'] ||= Regexp.new(gr), :regexp, index)
          r3 = true
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z0-9_]')
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        i5 = index
        if (match_len = has_terminal?('?', false, index))
          r6 = true
          @index += match_len
        else
          terminal_parse_failure('?')
          r6 = nil
        end
        if r6
          r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
          r5 = r6
        else
          if (match_len = has_terminal?('!', false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure('!')
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r5 = r7
          else
            @index = i5
            r5 = nil
          end
        end
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Identifier0)
      r0.extend(Identifier1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:identifier][start_index] = r0

    r0
  end

  module Self0
    def eval scope
      scope.this
    end
  end

  def _nt_self
    start_index = index
    if node_cache[:self].has_key?(index)
      cached = node_cache[:self][index]
      if cached
        node_cache[:self][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('@', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      r0.extend(Self0)
      @index += match_len
    else
      terminal_parse_failure('@')
      r0 = nil
    end

    node_cache[:self][start_index] = r0

    r0
  end

  module Comment0
  end

  module Comment1
  end

  module Comment2
    def eval scope
      # NO-OP, this is a comment for crying out loud! (:
    end
  end

  def _nt_comment
    start_index = index
    if node_cache[:comment].has_key?(index)
      cached = node_cache[:comment][index]
      if cached
        node_cache[:comment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('#', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('#')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        i5 = index
        if (match_len = has_terminal?("\n", false, index))
          r6 = true
          @index += match_len
        else
          terminal_parse_failure("\n")
          r6 = nil
        end
        if r6
          r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
          r5 = r6
        else
          if (match_len = has_terminal?("\r", false, index))
            r7 = true
            @index += match_len
          else
            terminal_parse_failure("\r")
            r7 = nil
          end
          if r7
            r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
            r5 = r7
          else
            @index = i5
            r5 = nil
          end
        end
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          if index < input_length
            r8 = true
            @index += 1
          else
            terminal_parse_failure("any character")
            r8 = nil
          end
          s3 << r8
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Comment0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        s9, i9 = [], index
        loop do
          i10 = index
          if (match_len = has_terminal?("\n", false, index))
            r11 = true
            @index += match_len
          else
            terminal_parse_failure("\n")
            r11 = nil
          end
          if r11
            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
            r10 = r11
          else
            if (match_len = has_terminal?("\r", false, index))
              r12 = true
              @index += match_len
            else
              terminal_parse_failure("\r")
              r12 = nil
            end
            if r12
              r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
              r10 = r12
            else
              @index = i10
              r10 = nil
            end
          end
          if r10
            s9 << r10
          else
            break
          end
        end
        if s9.empty?
          @index = i9
          r9 = nil
        else
          r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
        end
        s0 << r9
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Comment1)
      r0.extend(Comment2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:comment][start_index] = r0

    r0
  end

  def _nt_ws
    start_index = index
    if node_cache[:ws].has_key?(index)
      cached = node_cache[:ws][index]
      if cached
        node_cache[:ws][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?(' ', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure(' ')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?("\n", false, index))
        r2 = true
        @index += match_len
      else
        terminal_parse_failure("\n")
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        if (match_len = has_terminal?("\r", false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure("\r")
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:ws][start_index] = r0

    r0
  end

end

class QParser < Treetop::Runtime::CompiledParser
  include Q
end

